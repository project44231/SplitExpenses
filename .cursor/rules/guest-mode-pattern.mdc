---
description: Guest mode vs authenticated user handling pattern
globs: "**/providers/**/*.dart"
alwaysApply: false
---

# Guest Mode Pattern

## Provider Setup
Always add guest mode check in providers:

```dart
class MyNotifier extends StateNotifier<AsyncValue<List<Data>>> {
  final dynamic _authService;
  
  String get _userId => _authService.currentUserId ?? 'guest';
  bool get _isGuestMode => _authService.isGuestMode;
}
```

## Data Operations (Updated Pattern)
**Both guest and authenticated users = Firestore + local cache**

### Benefits
- ✅ Guest data persisted to cloud (survives cache clear)
- ✅ Multi-device access with same guest ID
- ✅ Easy migration to authenticated account
- ✅ GuestCleanupService works automatically
- ✅ Local cache provides offline access

### Save Pattern
```dart
// ✅ GOOD - Both guest and authenticated persist to Firestore
Future<void> saveData(Data data) async {
  // Save locally first (fast)
  await _localStorage.save(data);
  
  // Save to Firestore with userId (guest or authenticated)
  await _firestoreService.save(data, _userId);
}
```

### Load Pattern
```dart
// ✅ GOOD - Try Firestore first, fallback to local
Future<List<Data>> loadData() async {
  try {
    // Load from Firestore (both guest and authenticated)
    final data = await _firestoreService.getAll(_userId);
    
    // Cache locally for offline access
    for (final item in data) {
      await _localStorage.save(item);
    }
    
    return data;
  } catch (e) {
    // Fallback to local storage on error (offline mode)
    return await _localStorage.getAll();
  }
}
```

## Firestore Rules
Guest users identified by userId starting with 'guest' or 'guest_':
- Can read/write their own data
- Data isolated by userId
- GuestCleanupService periodically removes old guest data
